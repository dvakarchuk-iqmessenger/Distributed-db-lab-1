# Лабораторна робота №1
Розробка Ruby-додатку для збору та обробки інформації з інтернет-ресурсів.

## Етап 1
## Використані технології
- Мова: Ruby 3.4.7.
- Середовище розробки: RubyMine.
- Менеджер залежностей: Bundler.
- Бібліотеки для парсингу:
    - `httparty` – виконання HTTP-запитів.
    - `nokogiri` – парсинг HTML-документів.
- Інструмент контролю стилю: `rubocop`.

## Налаштування та запуск

1. Встановлення залежностей:
`bundle install`
2. Запуск тестового скрипта парсингу:
`ruby lib/main.rb`
3. Очікуваний результат:
- Виконується HTTP-запит до сторінки `https://example.com`.
- За допомогою `nokogiri` з HTML-документа зчитується тег `h1`.
- У консолі виводиться текст заголовка сторінки (`Example Domain`).

<img width="368" height="243" alt="image" src="https://github.com/user-attachments/assets/8a6db3ba-be02-44d9-a22b-15e7f01bcb9b" />



## Етап 2 – конфігурація через YAML

На цьому етапі налаштовано конфігурацію застосунку через YAML‑файли у директорії `config/`:

- `defaultconfig.yaml` – базові шляхи (`root_dir`, `config_dir`, `media_dir`).
- `webparser.yaml` – параметри парсингу (`start_page`, CSS‑селектори тощо).
- `logging.yaml` – налаштування логування (каталог логів, рівень, імена файлів).
- `databaseconfig.yaml` – початкова конфігурація підключення до бази даних (тип БД, шлях до файлу SQLite, таймаути, пул з’єднань).

Для роботи з конфігурацією реалізовано клас `AppConfigLoader` (`lib/app_config_loader.rb`), який:

- Знаходить YAML‑файли у директорії `config/`.
- Обробляє вміст через ERB (можна використовувати Ruby‑вирази в YAML).
- Завантажує та повертає дані у вигляді Ruby‑хешів через методи:
    - `load_default_config`
    - `load_webparser_config`
    - `load_logging_config`
    - `load_database_config`

Перевірка роботи конфігурації виконується через скрипт `lib/main.rb`, який зчитує всі чотири конфіг‑файли за допомогою `AppConfigLoader` та виводить їх вміст у консоль. Успішний запуск `ruby lib/main.rb` підтверджує коректну роботу системи конфігурацій.

<img width="1253" height="397" alt="image" src="https://github.com/user-attachments/assets/fe845724-d3eb-4beb-8b31-5c89a427069f" />



## Етап 3.1 – парсинг реального сайту

Обрано реальний тренувальний сайт для парсингу: [https://books.toscrape.com](https://books.toscrape.com).

### Реалізовано:

- Оновлену конфігурацію `webparser.yaml` для парсингу книжок: прописано селектори під структуру сайту (`product_selector`, `title_selector`, `price_selector`, `category_selector`, `image_selector`).
- Модуль `Lab1::WebsiteParser`, який автоматично отримує всі книжки з головної сторінки, видобуває для кожної книгии такі поля:
    - `name` (назва книги)
    - `price`
    - `description` (заповнено за замовчуванням)
    - `category` (“All books” для стартової сторінки)
    - `image_path` (відносна URL обкладинки)
- Для кожного об'єкта використовується клас `Item`.
- Весь процес парсингу логуються через модуль `LoggerManager` у файл логів.

### Результат

- Після запуску парсер витягує дані про 20 книжок та виводить їх у консоль.
- У логах (`logs/application.log`) фіксуються всі ключові дії (запит сторінки, парсинг книжок).
- При потребі, парсер легко розширюється для парсингу інших сторінок/категорій.

<img width="1832" height="714" alt="image" src="https://github.com/user-attachments/assets/e388c3d1-ddac-43dd-9d82-669686f2db49" />



## Етап 3.2 – колекція товарів та збереження даних

На цьому етапі реалізовано управління колекцією товарів (книжок), отриманих з парсера:

- Створено клас `Lab1::Cart`, який зберігає масив об’єктів `Item` та включає модуль `ItemContainer` (додавання/видалення/очищення колекції, метод `show_all_items` через `method_missing`) і модуль `Enumerable` для зручної роботи з колекцією.
- У модулі `ItemContainer` реалізовано:
    - `ClassMethods` (інформація про клас через `class_info`, підрахунок кількості створених екземплярів).
    - `InstanceMethods` (`add_item`, `remove_item`, `delete_items`, `show_all_items`).
- Клас `Cart` уміє зберігати колекцію товарів у різні формати:
    - текстовий файл `output/data.txt`;
    - JSON `output/data.json`;
    - CSV `output/data.csv`;
    - набір окремих YAML‑файлів у директорії `output/yaml_items/`.
- Для аналізу колекції реалізовано методи на основі `Enumerable`, зокрема підрахунок сумарної вартості (`total_price`) та фільтрацію товарів за ціною чи назвою.
- Усі ключові операції (створення кошика, додавання/видалення товарів, збереження у файли) логуються через `LoggerManager` у `logs/application.log`.

<img width="1573" height="953" alt="image" src="https://github.com/user-attachments/assets/637746d6-1eab-42ca-bc74-c7139d945044" />



## Етап 3.3 – керування сценаріями через Configurator

На цьому етапі додано можливість керувати послідовністю виконання кроків застосунку через конфігураційний файл.

- Створено YAML-файл `config/configurator.yaml`, у якому зберігаються прапорці для вмикання/вимикання окремих дій: `run_website_parser`, `run_save_to_csv`, `run_save_to_json`, `run_save_to_yaml`, `run_save_to_sqlite`, `run_save_to_mongodb`.
- Реалізовано клас `Lab1::Configurator`, який:
  - завантажує налаштування з `configurator.yaml` і об’єднує їх із дефолтними значеннями;
  - надає метод `configure` для зміни прапорців у рантаймі;
  - надає методи `available_methods` (список усіх дій) та `enabled?(key)` для перевірки, чи увімкнено конкретний крок.
- Оновлено `main.rb`, щоб логіка виконання залежала від `Configurator`:
  - якщо `run_website_parser = 1` – запускається парсер сайту й формується колекція товарів;
  - якщо `run_save_to_csv/json/yaml = 1` – колекція зберігається у відповідні файли за допомогою класу `Cart`;
  - прапорці для збереження в SQLite та MongoDB підготовлено як заготовки для наступних етапів.



## Етап 3.4 – SimpleWebsiteParser та робота з медіафайлами

На цьому етапі реалізовано більш гнучкий парсер на основі окремої конфігурації та додано збереження зображень товарів.

- Створено YAML-файл `config/simple_parser.yaml`, у якому задаються:
    - стартова сторінка (`start_page`);
    - CSS‑селектори для посилань на продукти, цін, описів, зображень та категорій;
    - каталог для медіафайлів (`media_dir`).
- Реалізовано клас `Lab1::SimpleWebsiteParser`, який:
    - завантажує налаштування з `simple_parser.yaml` та зберігає їх у атрибуті `config`;
    - має метод `start_parse`, що:
        - перевіряє доступність стартової сторінки,
        - отримує HTML‑код,
        - витягує посилання на окремі продукти,
        - у декількох потоках парсить сторінки товарів та наповнює колекцію `items`; 
    - містить окремі методи для витягання полів: `extract_product_name`, `extract_product_price`, `extract_product_description`, `extract_product_image`, `extract_product_category`, а також `check_url_response` для перевірки доступності URL. 
- Додано завантаження зображень товарів:
    - для кожного продукту визначається категорія, у каталозі `media/` створюється відповідна піддиректорія;
    - зображення зберігаються під безпечними іменами файлів (на основі назви книги) та шлях до них записується в поле `image_path` об’єкта `Item`. 
- Усі ключові дії SimpleWebsiteParser (початок парсингу, кількість знайдених посилань, обробка сторінок, помилки мережі та завантаження зображень) логуються через `LoggerManager`. 

<img width="1835" height="1011" alt="image" src="https://github.com/user-attachments/assets/62f12556-d4fe-40cb-be6f-4930345e21e5" />



## Етап 3.5 – підключення до бази даних (DatabaseConnector)

На цьому етапі реалізовано підключення до бази даних на основі конфігураційного файлу.

- Використовується файл `config/databaseconfig.yaml`, у якому задається тип БД (`databasetype`) та параметри для SQLite (шлях до файлу, таймаут, розмір пулу підключень).
- Створено клас `Lab1::DatabaseConnector`, який:
    - зчитує налаштування з `databaseconfig.yaml` та визначає тип БД (`sqlite` або `mongodb`);
    - має атрибут `db` для зберігання активного з’єднання;
    - реалізує метод `connect_to_database`, який в залежності від типу викликає приватні методи `connect_to_sqlite` або `connect_to_mongodb`;
    - реалізує метод `close_connection` для коректного закриття підключення (як для SQLite, так і для MongoDB).
- Для SQLite використовується гем `sqlite3`:
    - при підключенні за необхідності створюється каталог `db/` та файл `db/localdatabase.sqlite`;
    - у логах фіксується успішне підключення та закриття з’єднання.
- Для MongoDB додана заготовка під підключення через гем `mongo` (URI та ім’я бази визначаються конфігурацією), що дозволяє розширити застосунок у наступних етапах.
- Усі помилки під час підключення або закриття з’єднання обробляються й логуются через `LoggerManager`, зокрема випадок, коли вказано непідтримуваний тип БД.
